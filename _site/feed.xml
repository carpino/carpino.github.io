<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-04T13:45:28+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tollot’s Blog</title><subtitle>This blog want to be a collection of what i have learned  both working as a software developer and developing my side projects. I will write about backend software development, and in particular about distributed systems and formal methods.  </subtitle><entry><title type="html">Communicating over TCP with system calls in Go</title><link href="http://localhost:4000/jekyll/update/2024/01/04/TCP-syscalls.html" rel="alternate" type="text/html" title="Communicating over TCP with system calls in Go" /><published>2024-01-04T10:00:00+01:00</published><updated>2024-01-04T10:00:00+01:00</updated><id>http://localhost:4000/jekyll/update/2024/01/04/TCP-syscalls</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/01/04/TCP-syscalls.html">&lt;h1 id=&quot;tcp&quot;&gt;TCP&lt;/h1&gt;

&lt;p&gt;Transmission Controll Protocol (TCP) is the most used connection oriented network protocol over IP. 
Other than used directly, TCP is used also to implement other network protocols such as the widely known HTTP.&lt;/p&gt;

&lt;p&gt;TCP implements retransmission of the lost packets, for a number of times that has a default of 15, with the possibility for the client to receive duplicate packets, but these duplicates are managed by the protocol in a way that is transparent to the user.&lt;/p&gt;

&lt;p&gt;Packets are properly sequenced, that means they arrive in the same sequence in which they are sent.&lt;/p&gt;

&lt;p&gt;TCP is implemented at kernel level in the OS and is used by the networking libraries through a serie of system calls, these system calls can be implemented in other languages like C by the OS provider so that the networking libraries of the language of reference has not to implement them themselves at low level.&lt;/p&gt;

&lt;p&gt;The main syscalls for using TCP are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Socket&lt;/li&gt;
  &lt;li&gt;Bind&lt;/li&gt;
  &lt;li&gt;Listen&lt;/li&gt;
  &lt;li&gt;Accept&lt;/li&gt;
  &lt;li&gt;Connect&lt;/li&gt;
  &lt;li&gt;Write&lt;/li&gt;
  &lt;li&gt;Read&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;socket&quot;&gt;Socket&lt;/h4&gt;

&lt;p&gt;Create a new socket used in subsequent system calls. 
In the kernel level is created a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Protocol Control Block&lt;/code&gt; (PCB) that will contain all the informations about the current connection.
This is done through two calls, one for the allocation of the new PCB and one for its initialization.&lt;/p&gt;

&lt;h4 id=&quot;bind&quot;&gt;Bind&lt;/h4&gt;

&lt;p&gt;Bind a socket with a local transport network address, that is address and port. 
The port can also be not defined, in that case an implicit lookup will be tried by the system.
In case the port is already in use in the system by onehter socket, the bind will fail.&lt;/p&gt;

&lt;h4 id=&quot;listen&quot;&gt;Listen&lt;/h4&gt;

&lt;p&gt;Indicates to the protocol that the server process is ready to accept new incoming connections on the socket. 
It also indicates the number of connactions that can be queued, after which any further connection requests are ignored.
In the kernel level the call set the socket to listen state.&lt;/p&gt;

&lt;h4 id=&quot;accept&quot;&gt;Accept&lt;/h4&gt;

&lt;p&gt;Blocking call that waits for incoming connections. 
At incoming connection, a new socket descriptor is returned. 
This new socket is connected to the client and the previous socket remains in LISTEN state.
At kernel level when a new connection arrives, it wake up the server process passing it the new connection after have checked for socket errors tah mya have occured in the meantime.&lt;/p&gt;

&lt;h4 id=&quot;connect&quot;&gt;Connect&lt;/h4&gt;

&lt;p&gt;Used by the client process to connect to the server address through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-way tcp handshake&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;write&quot;&gt;Write&lt;/h4&gt;

&lt;p&gt;Send bytes through the socket making at kernel level the specific call for sending data through the network.
If the message is too large to live in a single packet (64K) it is decomposed in multiple packets in a way that is transparent to the user.
At kernel level data are appended to a sending buffer and then sent onto the network interface.&lt;/p&gt;

&lt;h4 id=&quot;read&quot;&gt;Read&lt;/h4&gt;

&lt;p&gt;Read bytes through the socket making at kernel level the specific calls for receiving data through the network, sending acks for received packets and copying received data from the socket buffer.&lt;/p&gt;

&lt;h1 id=&quot;syscalls-in-go&quot;&gt;Syscalls in GO&lt;/h1&gt;

&lt;p&gt;The syscall package provides a mean to interact with the underlying operating system directly.
However, it is essential to note that the syscall package is platform-specific, and some functions might not be available or behave differently across different platforms.&lt;/p&gt;

&lt;p&gt;For what regards at least the TCP calls, they are implemented in the syscall package under the hood with the use of the libc libraries.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc&lt;/code&gt; is responsible for the mechanism of system calls to the OS implemented in low level code.&lt;/p&gt;

&lt;p&gt;For our purposes we will use the procedures:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func syscall.Socket(domain int, typ int, proto int) (fd int, err error)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func syscall.Bind(fd int, sa syscall.Sockaddr) (err error)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func syscall.Listen(s int, backlog int) (err error)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func syscall.Accept(fd int) (nfd int, sa syscall.Sockaddr, err error)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func syscall.Connect(fd int, sa syscall.Sockaddr) (err error)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func syscall.Write(fd int, p []byte) (n int, err error)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func syscall.Read(fd int, p []byte) (n int, err error)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In particular the backlog parameter of the Listen procedure indicates the number of connection that can be put in the queue before beign ingored.&lt;/p&gt;

&lt;p&gt;For all the procedures &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; indicates a file descriptor.&lt;/p&gt;

&lt;p&gt;For the Socket procedure, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;domain&lt;/code&gt; indicates the address family, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type&lt;/code&gt; the type of socket(TCP or UDP), and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proto&lt;/code&gt; the underlaing protocol level IP.&lt;/p&gt;

&lt;p&gt;Based on the platform you are using you can receive an error in case the size of the  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; parameter in  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Write&lt;/code&gt; procedure is too big.&lt;/p&gt;

&lt;h1 id=&quot;example-code&quot;&gt;Example code&lt;/h1&gt;

&lt;p&gt;Here some example code using the previous described syscalls to send an hello message from one socket to the other.&lt;/p&gt;

&lt;h4 id=&quot;client&quot;&gt;Client&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_IP)
if err != nil {
        panic(err)
}

err = syscall.Bind(fd, &amp;amp;syscall.SockaddrInet4{Port: 8081, Addr: [4]byte{127, 0, 0, 1}})
if err != nil {
	panic(err)
}

err = syscall.Connect(fd, &amp;amp;syscall.SockaddrInet4{Port: 8080, Addr: [4]byte{127, 0, 0, 1}})
if err != nil {
	panic(err)
}

msg := &quot;hello world&quot;
size, err := syscall.Write(fd, []byte(msg))
if err != nil {
	panic(err)
}

println(&quot;written bytes: &quot;, size)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;server&quot;&gt;Server&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_IP)
if err != nil {
	panic(err)
}

err = syscall.Bind(fd, &amp;amp;syscall.SockaddrInet4{Port: 8080, Addr: [4]byte{127, 0, 0, 1}})
if err != nil {
	panic(err)
}

err = syscall.Listen(fd, 1)
if err != nil {
	panic(err)
}

nfd, _, err := syscall.Accept(fd)
if err != nil {
	panic(err)
}

buf := make([]byte, 1024)
size, err := syscall.Read(nfd, buf)
if err != nil {
	panic(err)
}

fmt.Println(size)
fmt.Println(string(buf[0:size]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;We have seen how to send and receive data over TCP using directly system calls, using the methods of the go’s syscall package (that are implemented using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc&lt;/code&gt; libraries of the OS provider).
We have tried to give some more awareness in the use of the TCP stack.
Hope you enjoied the article, if you want to either suggest some improvements or have an exhange please contact via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; or via my &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Twitter&lt;/code&gt; profile.&lt;/p&gt;

&lt;p&gt;References for this article:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.ibm.com/articles/au-tcpsystemcalls&quot;&gt;IBM TCP syscalls&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">TCP</summary></entry></feed>